[[servlet-saml2login]]
== SAML 2.0 Login
:figures: images/servlet/saml2
:icondir: images/icons

The SAML 2.0 Login feature provides an application with the capability to act as a SAML 2.0 Service Provider, having users log in to the application by using their existing account at a SAML 2.0 Identity Provider (Okta, ADFS, etc).

NOTE: SAML 2.0 Login is implemented by using the *Web Browser SSO Profile*, as specified in
https://www.oasis-open.org/committees/download.php/35389/sstc-saml-profiles-errata-2.0-wd-06-diff.pdf#page=15[SAML 2 Profiles].

[[servlet-saml2-spring-security-history]]
Since 2009, support for service providers has existed as an https://github.com/spring-projects/spring-security-saml/tree/1e013b07a7772defd6a26fcfae187c9bf661ee8f#spring-saml[extension project].
In 2019, the process began to port that into https://github.com/spring-projects/spring-security[Spring Security] proper.
This process is similar to the once started in 2017 for <<oauth2,Spring Security's OAuth 2.0 support>>.

[NOTE]
====
A working sample for {gh-samples-url}/boot/saml2login[SAML 2.0 Login] is available in the {gh-samples-url}[Spring Security repository].
====

[[servlet-saml2login-minimaldependencies]]
=== Minimal Dependencies

SAML 2.0 service provider support is found in `spring-security-saml2-service-provider`.
It builds off of the OpenSAML library.

[[servlet-saml2login-minimalconfiguration]]
=== Minimal Configuration

When using https://spring.io/projects/spring-boot[Spring Boot], configuring an application as a service provider consists of two basic steps.
First, include the needed dependencies and second, indicate the necessary identity provider metadata.

==== Specifying Identity Provider Metadata

In a Spring Boot application, to specify an identity provider's metadata, simply do:

[source,yml]
----
spring:
  security:
    saml2:
      relyingparty:
        registration:
          example:
            identityprovider:
              entity-id: https://idp.example.com/issuer
              verification.credentials:
                - certificate-location: "classpath:idp.crt"
              sso-url: https://idp.example.com/issuer/SSO.saml2
----

where

* `https://idp.example.com/issuer` is the value contained in the `Issuer` attribute SAML responses that the identity provider will issue
* `classpath:idp.crt` is the location on the classpath for the identity provider's certificate for verifying SAML responses, and
* `https://idp.example.com/issuer/SSO.saml2` is the endpoint where the identity provider is expecting `AuthnRequest` s.

And that's it!

From here, consider jumping to:

* <<servlet-saml2login-architecture,How SAML 2.0 Login Works>>
* <<servlet-saml2login-authenticatedprincipal,How to Use the `Saml2AuthenticatedPrincipal`>>
* <<servlet-saml2login-sansboot,How to Configure without Spring Boot>>

[[servlet-saml2login-architecture]]
=== How SAML 2.0 Login Works

When the above configuration is used, the application will automatically configure itself as a SAML 2.0 Service Provider - also called a relying party - that points to one or many identity providers - also called asserting parties.

[NOTE]
Identity Provider and Asserting Party are synonymous, as are Service Provider and Relying Party.

There are two supported authentication flows:

1. AP-Initiated flow, which is when you login in directly to the asserting party, and then select a web application to be authenticated for.
2. RP-Initiated flow, which is when you access your relying party, and it sends an authentication request to the asserting party.
You then authenticate and are redirected back to the relying party.

To see this in action, you can navigate to a protected page in your app, for example `http://localhost:8080` is protected by default, and it will redirect you to the configured aserting party where you can authenticate.

Once authenticated, the asserting party will issue an authentication response.
Your application will then:

1. Validate the response's signature against the set of public keys obtained from configuration
2. Decrypt any encrypted assertions
3. Validate the `ExpiresAt` and `NotBefore` timestamps and the `Issuer` url
4. Map each attribute in the `AttributeStatement` into principal attributes
5. Grant the authority `ROLE_USER` to the resulting authentication

[TIP]
Because Spring Security iterates through the set of configured public keys, it's possible to achieve key rotation by adding a new key to the list before removing a key you are retiring.

The resulting `Authentication#getPrincipal`, by default, is a Spring Security `Saml2AuthenticatedPrincipal` object, and `Authentication#getName` maps to the first assertion's `NameID` element, if one is present.

[[servlet-saml2login-sansboot]]
=== Overriding or Replacing Boot Auto Configuration

There are two `@Bean` s that Spring Boot generates for a relying party.

The first is a `WebSecurityConfigurerAdapter` that configures the app as a relying party.
When including `spring-security-saml2-service-provider`, the `WebSecurityConfigurerAdapter` looks like:

.Default JWT Configuration
====
.Java
[source,java,role="primary"]
----
protected void configure(HttpSecurity http) {
    http
        .authorizeRequests(authorize -> authorize
            .anyRequest().authenticated()
        )
        .saml2Login(saml2 -> {});
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
fun configure(http: HttpSecurity) {
    http {
        authorizeRequests {
            authorize(anyRequest, authenticated)
        }
        saml2Login { }
    }
}
----
====

If the application doesn't expose a `WebSecurityConfigurerAdapter` bean, then Spring Boot will expose the above default one.

Replacing this is as simple as exposing the bean within the application:

.Custom JWT Configuration
====
.Java
[source,java,role="primary"]
----
@EnableWebSecurity
public class MyCustomSecurityConfiguration extends WebSecurityConfigurerAdapter {
    protected void configure(HttpSecurity http) {
        http
            .authorizeRequests(authorize -> authorize
                .mvcMatchers("/messages/**").hasAuthority("SCOPE_message:read")
                .anyRequest().authenticated()
            )
            .saml2Login(saml2 -> saml2
                .relyingPartyRegistrationRepository(myRepository())
            );
    }
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@EnableWebSecurity
class MyCustomSecurityConfiguration : WebSecurityConfigurerAdapter() {
    override fun configure(http: HttpSecurity) {
        http {
            authorizeRequests {
                authorize("/messages/**", hasAuthority("SCOPE_message:read"))
                authorize(anyRequest, authenticated)
            }
            saml2Login {
                relyingPartyRegistrationRepository = myRepository()
            }
        }
    }
}
----
====

The above requires the scope of `message:read` for any URL that starts with `/messages/`.

Methods on the `saml2Login` DSL will also override or replace auto configuration.

[[servlet-saml2login-relyingpartyregistrationrepository]]
For example, the second `@Bean` Spring Boot creates is a `RelyingPartyRegistrationRepository`, which represents the AP and RP metadata.
This includes things like the location of the SSO endpoint the relying party should use when requesting authentication from the asserting party.

You can override the default by publishing your own `RelyingPartyRegistrationRepository` bean.
For example, the equivalent for the earlier configuration would be:

.Relying Party Registration Repository
====
[source,java]
----
@Value("${spring.security.saml2.relyingparty.registration.example.identityprovider.verification.credentials}")
List<RSAPublicKey> keys;

@Bean
public RelyingPartyRegistrationRepository relyingPartyRegistrations() {
	RelyingPartyRegistration registration = withRelyingPartyRegistration("example")
            .providerDetails(p -> p
                    .entityId("https://idp.example.com/issuer")
                    .webSsoUrl("https://idp.example.com/SSO.saml2")
                    .signAuthnRequest(false)
            )
            .credentials(c -> c.addAll(this.keys))
            .build();
    return new InMemoryRelyingPartyRegistrationRepository(registration);
}
----
====

[[servlet-saml2login-relyingpartyregistrationrepository-dsl]]

Alternatively, you can directly wire up the repository using the DSL:

[source,java]
----
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .authorizeRequests(authorize -> authorize
                .anyRequest().authenticated()
            )
            .saml2Login(saml2 -> saml2
                .relyingPartyRegistrationRepository(myRe)
            );
    }
}
----

[[servlet-saml2-relyingpartyregistration]]
==== RelyingPartyRegistration
The https://github.com/spring-projects/spring-security/blob/5.2.0.RELEASE/saml2/saml2-service-provider/src/main/java/org/springframework/security/saml2/provider/service/registration/RelyingPartyRegistration.java[`RelyingPartyRegistration`]
object represents the mapping between this application, the SP, and the asserting party, the IDP.

[[servlet-saml2-rpr-uripatterns]]
===== URI Patterns

URI patterns are frequenty used to automatically generate URIs based on
an incoming request. The URI patterns in `saml2Login` can contain the following variables

* `baseUrl`
* `registrationId`
* `baseScheme`
* `baseHost`
* `basePort`

For example:
`+{baseUrl}/login/saml2/sso/{registrationId}+`

[[servlet-saml2-rpr-relyingparty]]
===== Relying Party

* `registrationId` - (required) a unique identifer for this configuration mapping.
This identifier may be used in URI paths, so care should be taken that no URI encoding is required.
* `localEntityIdTemplate` - (optional) A URI pattern that creates an entity ID for this application based on the incoming request. The default is
`+{baseUrl}/saml2/service-provider-metadata/{registrationId}+` and for a small sample application
it would look like
```
http://localhost:8080/saml2/service-provider-metadata/my-test-configuration
```
There is no requirement that this configuration option is a pattern, it can be a fixed URI value.

* `assertionConsumerServiceUrlTemplate` - (optional) A URI pattern that denotes the assertion
consumer service URI to be sent with any `AuthNRequest` from the SP to the IDP during the SP initiated flow.
While this can be a pattern the actual URI must resolve to the ACS endpoint on the SP.
The default value is `+{baseUrl}/login/saml2/sso/{registrationId}+` and maps directly to the
https://github.com/spring-projects/spring-security/blob/5.2.0.RELEASE/saml2/saml2-service-provider/src/main/java/org/springframework/security/saml2/provider/service/servlet/filter/Saml2WebSsoAuthenticationFilter.java#L42[`Saml2WebSsoAuthenticationFilter`] endpoint
* `credentials` - A list of credentials, private keys and x509 certificates, used for
message signing, verification, encryption and decryption.
This list can contain redundant credentials to allow for easy rotation of credentials.
For example
** [0] - X509Certificate{VERIFICATION,ENCRYPTION} - The IDP's first public key used for
verification and encryption.
** [1] - X509Certificate/{VERIFICATION,ENCRYPTION} - The IDP's second verification key used for verification.
Encryption is always done using the first `ENCRYPTION` key in the list.
** [2] - PrivateKey/X509Certificate{SIGNING,DECRYPTION} - The SP's first signing and decryption credential.
** [3] - PrivateKey/X509Certificate{SIGNING,DECRYPTION} - The SP's second decryption credential.
Signing is always done using the first `SIGNING` key in the list.
* `ProviderDetails#entityId` - (required) the entity ID of the Identity Provider. Always a fixed URI value or string,
no patterns allowed.
* `ProviderDetails#webSsoUrl`  - (required) a fixed URI value for the IDP Single Sign On endpoint where
the SP sends the `AuthNRequest` messages.
* `ProviderDetails#signAuthNRequest` - A boolean indicating whether or not to sign the `AuthNRequest` with the SP's private key, defaults to `true`
* `ProviderDetails#binding` - A `Saml2MessageBinding` indicating what kind of binding to use for the `AuthNRequest`, whether that be `REDIRECT` or `POST`, defaults to `REDIRECT`

When an incoming message is received, signatures are always required, the system will first attempt
to validate the signature using the certificate at index [0] and only move to the second
credential if the first one fails.

In a similar fashion, the SP configured private keys are used for decryption and attempted in the same order.
The first SP credential (`type=SIGNING`) will be used when messages to the IDP are signed.

[[servlet-saml2-rpr-duplicated]]
===== Duplicated Relying Party Configurations

In the use case where an application uses multiple identity providers it becomes
obvious that some configuration is duplicated between two `RelyingPartyRegistration` objects

* localEntityIdTemplate
* credentials (all SP credentials, IDP credentials change)
* assertionConsumerServiceUrlTemplate

While there is some drawback in duplicating configuration values the back end
configuration repository does not need to replicate this data storage model.

There is a benefit that comes with this setup. Credentials may be more easily rotated
for some identity providers vs others. This object model can ensure that there is no
disruption when configuration is changed in a multi IDP use case and you're not able to rotate
credentials on all the identity providers.

[[servlet-saml2-serviceprovider-metadata]]
==== Service Provider Metadata

The Spring Security SAML 2 implementation does not yet provide an endpoint for downloading
SP metadata in XML format. The minimal pieces that are exchanged

* *entity ID* - defaults to `+{baseUrl}/saml2/service-provider-metadata/{registrationId}+`
Other known configuration names that also use this same value
** Audience Restriction
* *single signon URL* - defaults to `+{baseUrl}/login/saml2/sso/{registrationId}+`
Other known configuration names that also use this same value
** Recipient URL
** Destination URL
** Assertion Consumer Service URL
* X509Certificate - the certificate that you configure as part of your {SIGNING,DECRYPTION}
credentials must be shared with the Identity Provider

[[servlet-saml2-sp-initiated]]
==== Authentication Requests - SP Initiated Flow

To initiate an authentication from the web application, you can redirect to:

`+{baseUrl}/saml2/authenticate/{registrationId}+`

This endpoint will generate an `AuthNRequest` either as a Redirect or POST depending on your `RelyingPartyRegistration`.

[[servlet-saml2-sp-initiated-factory]]
==== Customizing the AuthNRequest

To adjust the `AuthNRequest`, you can publish an instance of `Saml2AuthenticationRequestFactory`.

For example, if you wanted to configure the `AuthNRequest` to request the IDP to send the SAML `Assertion` by REDIRECT, you could do:

[source,java]
----
@Bean
public Saml2AuthenticationRequestFactory authenticationRequestFactory() {
    OpenSamlAuthenticationRequestFactory authenticationRequestFactory =
        new OpenSamlAuthenticationRequestFactory();
    authenticationRequestFactory.setProtocolBinding("urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Redirect");
    return authenticationRequestFactory;
}
----

[[servlet-saml2-sp-initiated-factory-delegate]]
==== Delegating to an AuthenticationRequestFactory

Or, in circumstances where you need more control over what is sent as parameters to the `AuthenticationRequestFactory`, you can use delegation:

[source,java]
----
@Component
public class IssuerSaml2AuthenticationRequestFactory implements Saml2AuthenticationRequestFactory {
	private OpenSamlAuthenticationRequestFactory delegate = new OpenSamlAuthenticationRequestFactory();

	@Override
	public String createAuthenticationRequest(Saml2AuthenticationRequest request) {
		return this.delegate.createAuthenticationRequest(request);
	}

	@Override
    public Saml2PostAuthenticationRequest createPostAuthenticationRequest
        (Saml2AuthenticationRequestContext context) {

		String issuer = // ... calculate issuer

		Saml2AuthenticationRequestContext customIssuer = Saml2AuthenticationRequestContext.builder()
                .assertionConsumerServiceUrl(context.getAssertionConsumerServiceUrl())
                .issuer(issuer)
                .relayState(context.getRelayState())
                .relyingPartyRegistration(context.getRelyingPartyRegistration())
                .build();

		return this.delegate.createPostAuthenticationRequest(customIssuer);
	}

	@Override
    public Saml2RedirectAuthenticationRequest createRedirectAuthenticationRequest
        (Saml2AuthenticationRequestContext context) {

		throw new UnsupportedOperationException("unsupported");
	}
}
----

[[servlet-saml2-login-customize]]
=== Customizing Authentication Logic

By default Spring Security configures the `OpenSamlAuthenticationProvider`
to validate and parse the SAML 2 response and assertions that are received.
This provider has three configuration options

1. An authorities extractor - extract group information from the assertion
2. An authorities mapper - map extracted group information to internal authorities
3. Response time validation duration - the built in tolerances for timestamp validation
should be used when there may be a time synchronization issue.

One customization strategy is to use an `ObjectPostProcessor`, which allows you to modify the
objects created by the implementation. Another option is to override the authentication
manager for the filter that intercepts the SAMLResponse.

[[servlet-saml2-opensamlauthenticationprovider]]
==== OpenSamlAuthenticationProvider ObjectPostProcessor

[source,java]
----
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        ObjectPostProcessor<OpenSamlAuthenticationProvider> processor = new ObjectPostProcessor<>() {
            @Override
            public <O extends OpenSamlAuthenticationProvider> O postProcess(O provider) {
                provider.setResponseTimeValidationSkew(RESPONSE_TIME_VALIDATION_SKEW);
                provider.setAuthoritiesMapper(AUTHORITIES_MAPPER);
                provider.setAuthoritiesExtractor(AUTHORITIES_EXTRACTOR);
                return provider;
            }
        };

        http
            .authorizeRequests(authorize -> authorize
                .anyRequest().authenticated()
            )
            .saml2Login(saml2 -> saml2
               .addObjectPostProcessor(processor)
            )
        ;
    }
}
----

[[servlet-saml2-opensamlauthenticationprovider-authenticationmanager]]
==== Configure OpenSamlAuthenticationProvider as an Authentication Manager
We can leverage the same method, `authenticationManager`, to override and customize the default
`OpenSamlAuthenticationProvider`.

[source,java]
----
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        OpenSamlAuthenticationProvider authProvider = new OpenSamlAuthenticationProvider();
        authProvider.setResponseTimeValidationSkew(RESPONSE_TIME_VALIDATION_SKEW);
        authProvider.setAuthoritiesMapper(AUTHORITIES_MAPPER);
        authProvider.setAuthoritiesExtractor(AUTHORITIES_EXTRACTOR);
        http
            .authorizeRequests(authorize -> authorize
                .anyRequest().authenticated()
            )
            .saml2Login(saml2 -> saml2
                .authenticationManager(new ProviderManager(asList(authProvider)))
            )
        ;
    }
}
----

[[servlet-saml2-custom-authenticationmanager]]
==== Custom Authentication Manager
The authentication manager for the security filter can also be overwritten, using your own
custom `AuthenticationManager` implementation.
This authentication manager should expect a `Saml2AuthenticationToken` object
containing the SAML 2 Response XML data.

[source,java]
----
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        AuthenticationManager authenticationManager = new MySaml2AuthenticationManager(...);
        http
            .authorizeRequests(authorize -> authorize
                .anyRequest().authenticated()
            )
            .saml2Login(saml2 -> saml2
                .authenticationManager(authenticationManager)
            )
        ;
    }
}
----

[[servlet-saml2-sample-boot]]
=== Spring Boot 2.x Sample

We are currently working with the Spring Boot team on the
https://github.com/spring-projects/spring-boot/issues/18260[Auto Configuration for Spring Security SAML Login].
In the meantime, we have provided a Spring Boot sample that supports a Yaml configuration.

To run the sample, follow these three steps

1. Launch the Spring Boot application
** `./gradlew :spring-security-samples-boot-saml2login:bootRun`
2. Open a browser
** http://localhost:8080/[http://localhost:8080/]
3. This will take you to an identity provider, log in using:
** User: `user`
** Password: `password`

[[servlet-saml2-sample-idps]]
==== Multiple Identity Provider Sample

It's very simple to use multiple providers, but there are some defaults that
may trip you up if you don't pay attention. In our SAML configuration of
`RelyingPartyRegistration` objects, we default an SP entity ID to
`+{baseUrl}/saml2/service-provider-metadata/{registrationId}+`

That means in our two provider configuration, our system would look like

```
registration-1 (Identity Provider 1) - Our local SP Entity ID is:
http://localhost:8080/saml2/service-provider-metadata/registration-1

registration-2 (Identity Provider 2) - Our local SP Entity ID is:
http://localhost:8080/saml2/service-provider-metadata/registration-2
```

In this configuration, illustrated in the sample below, to the outside world,
we have actually created two virtual Service Provider identities
hosted within the same application.

[source,yaml]
----
spring:
  security:
    saml2:
      login:
        relying-parties:
          - entity-id: &idp-entity-id https://simplesaml-for-spring-saml.cfapps.io/saml2/idp/metadata.php
            registration-id: simplesamlphp
            web-sso-url: &idp-sso-url https://simplesaml-for-spring-saml.cfapps.io/saml2/idp/SSOService.php
            signing-credentials: &service-provider-credentials
              - private-key: |
                  -----BEGIN PRIVATE KEY-----
                  MIICeAIBADANBgkqhkiG9w0BAQEFAASCAmIwggJeAgEAAoGBANG7v8QjQGU3MwQE
                  ...................SHORTENED FOR READ ABILITY...................
                  INrtuLp4YHbgk1mi
                  -----END PRIVATE KEY-----
                certificate: |
                  -----BEGIN CERTIFICATE-----
                  MIICgTCCAeoCCQCuVzyqFgMSyDANBgkqhkiG9w0BAQsFADCBhDELMAkGA1UEBhMC
                  ...................SHORTENED FOR READ ABILITY...................
                  RZ/nbTJ7VTeZOSyRoVn5XHhpuJ0B
                  -----END CERTIFICATE-----
            verification-credentials: &idp-certificates
              - |
                -----BEGIN CERTIFICATE-----
                MIIEEzCCAvugAwIBAgIJAIc1qzLrv+5nMA0GCSqGSIb3DQEBCwUAMIGfMQswCQYD
                ...................SHORTENED FOR READ ABILITY...................
                lx13Y1YlQ4/tlpgTgfIJxKV6nyPiLoK0nywbMd+vpAirDt2Oc+hk
                -----END CERTIFICATE-----
          - entity-id: *idp-entity-id
            registration-id: simplesamlphp2
            web-sso-url: *idp-sso-url
            signing-credentials: *service-provider-credentials
            verification-credentials: *idp-certificates
----

If this is not desirable, you can manually override the local SP entity ID by using the

[source,attrs="-attributes"]
----
localEntityIdTemplate = {baseUrl}/saml2/service-provider-metadata
----

If we change our local SP entity ID to this value, it is still important that we give
out the correct single sign on URL (the assertion consumer service URL)
for each registered identity provider based on the registration Id.
`+{baseUrl}/login/saml2/sso/{registrationId}+`


