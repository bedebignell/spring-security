[[servlet-saml2login]]
== SAML 2.0 Login
:figures: images/servlet/saml2
:icondir: images/icons

The SAML 2.0 Login feature provides an application with the capability to act as a SAML 2.0 Service Provider, having users log in to the application by using their existing account at a SAML 2.0 Identity Provider (Okta, ADFS, etc).

NOTE: SAML 2.0 Login is implemented by using the *Web Browser SSO Profile*, as specified in
https://www.oasis-open.org/committees/download.php/35389/sstc-saml-profiles-errata-2.0-wd-06-diff.pdf#page=15[SAML 2 Profiles].

[[servlet-saml2-spring-security-history]]
Since 2009, support for service providers has existed as an https://github.com/spring-projects/spring-security-saml/tree/1e013b07a7772defd6a26fcfae187c9bf661ee8f#spring-saml[extension project].
In 2019, the process began to port that into https://github.com/spring-projects/spring-security[Spring Security] proper.
This process is similar to the once started in 2017 for <<oauth2,Spring Security's OAuth 2.0 support>>.

[NOTE]
====
A working sample for {gh-samples-url}/boot/saml2login[SAML 2.0 Login] is available in the {gh-samples-url}[Spring Security repository].
====

[[servlet-saml2login-minimaldependencies]]
=== Minimal Dependencies

SAML 2.0 service provider support is found in `spring-security-saml2-service-provider`.
It builds off of the OpenSAML library.

[[servlet-saml2login-minimalconfiguration]]
=== Minimal Configuration

When using https://spring.io/projects/spring-boot[Spring Boot], configuring an application as a service provider consists of two basic steps.
First, include the needed dependencies and second, indicate the necessary identity provider metadata.

==== Specifying Identity Provider Metadata

In a Spring Boot application, to specify an identity provider's metadata, simply do:

[source,yml]
----
spring:
  security:
    saml2:
      relyingparty:
        registration:
          example:
            identityprovider:
              entity-id: https://idp.example.com/issuer
              verification.credentials:
                - certificate-location: "classpath:idp.crt"
              sso-url: https://idp.example.com/issuer/SSO.saml2
----

where

* `https://idp.example.com/issuer` is the value contained in the `Issuer` attribute of the SAML responses that the identity provider will issue
* `classpath:idp.crt` is the location on the classpath for the identity provider's certificate for verifying SAML responses, and
* `https://idp.example.com/issuer/SSO.saml2` is the endpoint where the identity provider is expecting `AuthnRequest` s.

And that's it!

From here, consider jumping to:

* <<servlet-saml2login-architecture,How SAML 2.0 Login Works>>
* <<servlet-saml2login-authenticatedprincipal,How to Use the `Saml2AuthenticatedPrincipal`>>
* <<servlet-saml2login-sansboot,How to Configure without Spring Boot>>

[[servlet-saml2login-architecture]]
=== How SAML 2.0 Login Works

When the above configuration is used, the application will automatically configure itself as a SAML 2.0 Service Provider - also called a relying party - that points to one or many identity providers - also called asserting parties.

[NOTE]
Identity Provider and Asserting Party are synonymous, as are Service Provider and Relying Party.

There are two supported authentication flows:

1. AP-Initiated flow, which is when you login in directly to the asserting party, and then select a web application to be authenticated for.
2. RP-Initiated flow, which is when you access your relying party, and it sends an authentication request to the asserting party.
You then authenticate and are redirected back to the relying party.

To see this in action, you can navigate to a protected page in your app, for example `http://localhost:8080` is protected by default, and it will redirect you to the configured aserting party where you can authenticate.

Once authenticated, the asserting party will issue an authentication response.
Your application will then:

1. Validate the response's signature against the set of public keys obtained from configuration
2. Decrypt any encrypted assertions
3. Validate the `ExpiresAt` and `NotBefore` timestamps and the `Issuer` url
4. Map each attribute in the `AttributeStatement` into principal attributes
5. Grant the authority `ROLE_USER` to the resulting authentication

[TIP]
Because Spring Security iterates through the set of configured public keys, it's possible to achieve key rotation by adding a new key to the list before removing a key you are retiring.

The resulting `Authentication#getPrincipal`, by default, is a Spring Security `Saml2AuthenticatedPrincipal` object, and `Authentication#getName` maps to the first assertion's `NameID` element, if one is present.

[[servlet-saml2login-sansboot]]
=== Overriding or Replacing Boot Auto Configuration

There are two `@Bean` s that Spring Boot generates for a relying party.

The first is a `WebSecurityConfigurerAdapter` that configures the app as a relying party.
When including `spring-security-saml2-service-provider`, the `WebSecurityConfigurerAdapter` looks like:

.Default JWT Configuration
====
.Java
[source,java,role="primary"]
----
protected void configure(HttpSecurity http) {
    http
        .authorizeRequests(authorize -> authorize
            .anyRequest().authenticated()
        )
        .saml2Login(saml2 -> {});
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
fun configure(http: HttpSecurity) {
    http {
        authorizeRequests {
            authorize(anyRequest, authenticated)
        }
        saml2Login { }
    }
}
----
====

If the application doesn't expose a `WebSecurityConfigurerAdapter` bean, then Spring Boot will expose the above default one.

Replacing this is as simple as exposing the bean within the application:

.Custom SAML 2.0 Login Configuration
====
.Java
[source,java,role="primary"]
----
@EnableWebSecurity
public class MyCustomSecurityConfiguration extends WebSecurityConfigurerAdapter {
    protected void configure(HttpSecurity http) {
        http
            .authorizeRequests(authorize -> authorize
                .mvcMatchers("/messages/**").hasAuthority("ROLE_USER")
                .anyRequest().authenticated()
            )
            .saml2Login(saml2 -> {});
    }
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@EnableWebSecurity
class MyCustomSecurityConfiguration : WebSecurityConfigurerAdapter() {
    override fun configure(http: HttpSecurity) {
        http {
            authorizeRequests {
                authorize("/messages/**", hasAuthority("ROLE_USER"))
                authorize(anyRequest, authenticated)
            }
            saml2Login {
            }
        }
    }
}
----
====

The above requires the role of `USER` for any URL that starts with `/messages/`.

[[servlet-saml2login-relyingpartyregistrationrepository]]
The second `@Bean` Spring Boot creates is a `RelyingPartyRegistrationRepository`, which represents the AP and RP metadata.
This includes things like the location of the SSO endpoint the relying party should use when requesting authentication from the asserting party.

You can override the default by publishing your own `RelyingPartyRegistrationRepository` bean.
For example, the equivalent for the earlier configuration would be:

.Relying Party Registration Repository
====
[source,java]
----
@Bean
public RelyingPartyRegistrationRepository relyingPartyRegistrations() {
	Saml2X509Credential verification = new Saml2X509Credential(
        assertingPartyVerificationCertificate(),
        Saml2X509Credential.Saml2X509CredentialType.VERIFICATION);

	RelyingPartyRegistration registration = withRelyingPartyRegistration("example")
            .providerDetails(p -> p
                    .entityId("https://idp.example.com/issuer")
                    .webSsoUrl("https://idp.example.com/SSO.saml2")
                    .signAuthnRequest(false)
            )
            .credentials(c -> c.addAll(this.keys))
            .build();
    return new InMemoryRelyingPartyRegistrationRepository(registration);
}

private X509Certificate assertingPartyVerificationCertificate() {
	ClassPathResource certificateLocation = new ClassPathResource("idp.crt");
	try (InputStream certiticateStream = certificateLocation.getInputStream()) {
        return (X509Certificate) CertificateFactory.getInstance("X.509").generateCertificate(certificateStream);
	} catch (IOException e) {
		throw new IllegalArgumentException(e);
	}
}
----
====

[[servlet-saml2login-relyingpartyregistrationrepository-dsl]]

Alternatively, you can directly wire up the repository using the DSL, which will also override the auto-configuration:

.Custom Relying Party Registration DSL
====
.Java
[source,java,role="primary"]
----
@EnableWebSecurity
public class MyCustomSecurityConfiguration extends WebSecurityConfigurerAdapter {
    protected void configure(HttpSecurity http) {
        http
            .authorizeRequests(authorize -> authorize
                .mvcMatchers("/messages/**").hasAuthority("ROLE_USER")
                .anyRequest().authenticated()
            )
            .saml2Login(saml2 -> saml2
                .relyingPartyRegistrationRepository(relyingPartyRegistrations())
            );
    }
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@EnableWebSecurity
class MyCustomSecurityConfiguration : WebSecurityConfigurerAdapter() {
    override fun configure(http: HttpSecurity) {
        http {
            authorizeRequests {
                authorize("/messages/**", hasAuthority("ROLE_USER"))
                authorize(anyRequest, authenticated)
            }
            saml2Login {
                relyingPartyRegistrationRepository = relyingPartyRegistrations()
            }
        }
    }
}
----
====

[NOTE]
A relying party can be multi-tenant by registering more than one relying party in the `RelyingPartyRegistrationRepository`.

[[servlet-saml2-relyingpartyregistration]]
==== RelyingPartyRegistration
A https://github.com/spring-projects/spring-security/blob/5.2.0.RELEASE/saml2/saml2-service-provider/src/main/java/org/springframework/security/saml2/provider/service/registration/RelyingPartyRegistration.java[`RelyingPartyRegistration`]
instance represents a link between an RP and AP's metadata.

In a `RelyingPartyRegistration`, you can provide RP metadata like its `Issuer` value, where it expects SAML Responses to be sent to, and any credentials that it owns for the purposes of signing or decrypting payloads.

Also, you can provide AP metadata like its `Issuer` value, where it expects AuthnRequests to be sent to, and any credentials that it owns for the purposes of the RP verifying or encrypting paylods.

The following `RelyingPartyRegistration` is the minimum required for most setups:

[source,java]
----
RelyingPartyRegistration relyingPartyRegistration = RelyingPartyRegistration.withRegistrationId("my-id")
        .credentials(c -> c.add(assertingPartyVerifyingCredential()))
        .assertingParty(ap -> ap
                .entityId("https://ap.example.org")
                .webSsoUrl("https://ap.example.org/SSO.saml2")
        );
----

Though a more sophisticated setup is also possible, like so:

[source,java]
----
RelyingPartyRegistration relyingPartyRegistration = RelyingPartyRegistration.withRegistrationId("my-id")
        .entityId("{baseUrl}/{registrationId}")
        .authenticationResponseUri("/my-login-endpoint/{registrationId}")
        .credentials(c -> c.add(relyingPartyDecryptingCredential()))
        .assertingParty(ap -> ap
                .entityId("https://ap.example.org")
                .authenticationRequestUri("https://ap.example.org/SSO.saml2")
                .credentials(c -> c.add(assertingPartyVerifyingCredential()))
        );
----

[TIP]
The top-level metadata methods are details about the RP. The methods inside `assertingParty` are details about the AP.

[NOTE]
The location where an RP is expecting SAML Responses is also knows as the Assertion Consumer Service URL.

The default for the RP's `entityId` is `{baseUrl}/saml2/service-provider-metadata/{registrationId}`.
This is this value needed when configuring the AP to know about your RP.

The default for the `authenticationResponseUri` is `/login/saml2/sso/{registrationId}`.
It's mapped by default to https://github.com/spring-projects/spring-security/blob/5.2.0.RELEASE/saml2/saml2-service-provider/src/main/java/org/springframework/security/saml2/provider/service/servlet/filter/Saml2WebSsoAuthenticationFilter.java#L42[`Saml2WebSsoAuthenticationFilter`] in the filter chain.

[[servlet-saml2-rpr-uripatterns]]
===== URI Patterns

You probably noticed in the above examples the `{baseUrl}` and `{registrationId}` placeholders.

These are useful for generating URIs. As such, the RP's `entityId` and `authenticationResponseUri` support the following placeholders:

* `baseUrl` - the scheme, host, and port of a deployed application
* `registrationId` - the registration id for this relying party
* `baseScheme` - the scheme of a deployed application
* `baseHost` - the host of a deployed application
* `basePort` - the port of a deployed application

For example, the `authenticationResponseUri` defined above was:

`+/my-login-endpoint/{registrationId}+`

which in a deployed application would translate to

`+/my-login-endpoint/my-id`

The `entityId` above was defined as:

`+{baseUrl}/{registrationId}+`

which in a deployed application would translate to

`+https://rp.example.org/my-id+`

[[servlet-saml2-rpr-credentials]]
===== Credentials

You also likely noticed the credential that was logged.

Oftentimes, an RP will use the same key to sign payloads as well as decrypt them.
Or it will use the same key to verify payloads as well as encrypt them.

Because of this, Spring Security ships with `Saml2X509Credential`, a SAML-specific credential that simplifies configuring the same key for different use cases.

At a minimum, it's necessary to have a certificate from the Asserting Party so that the AP's signed responses can be verified.

To construct a `Saml2X509Credential` that you'll use to verify assertions from the Asserting Party, you can load the file and use `CertificateFactory` like so:

[source,java]
----
Resource resource = new ClassPathResource("ap.crt");
try (InputStream is = resource.getInputStream()) {
	X509Certificate certificate = (X509Certificate)
            CertificateFactory.getInstance("X.509").generateCertificate(is);
	return new Saml2X509Credential(certificate, VERIFICATION);
}
----

The first parameter is Java's representation of an X.509 certificate.
The second is the circumstance when it may be used.

Let's say that the Asserting Party is going to also encrypt the assertion.
In that case, the Relying Party will need a private key to be able to decrypt the encrypted value.

In that case, you'll need an `RSAPrivateKey` as well as its corresponding `X509Certificate`.
You can load the first using Spring Security's `RsaKeyConverters` utility class and the second as you did before:

[source,java]
----
X509Certificate certificate = relyingPartyDecryptionCertificate();
Resource resource = new ClassPathResource("rp.crt");
try (InputStream is = resource.getInputStream()) {
	RSAPrivateKey rsa = RsaKeyConverters.pkcs8().convert(is);
	return new Saml2X509Credential(certificate, rsa, DECRYPTION);
}
----

[TIP]
When you specify the locations of these files as the appropriate Spring Boot properties, then Spring Boot will perform these conversions for you.

[[servlet-saml2-rpr-duplicated]]
===== Duplicated Relying Party Configurations

When an application uses multiple asserting parties, some configuration is duplicated between `RelyingPartyRegistration` objects:

* The RP's `entityId` template
* Its `authenticationResponseUri` template, and
* Its credentials, e.g. its decryption credential

[TIP]
While there is some drawback in duplicating configuration values, the back end configuration repository does not need to replicate this data storage model.

There is a benefit that comes with this setup.

Credentials may be more easily rotated for some identity providers vs others.
This object model can ensure that there is no disruption when configuration is changed in a multi-AP use case and you're not able to rotate
credentials on all the asserting parties.

[[servlet-saml2-sp-initiated]]
==== SP-initiated Login

Recall what's been said already about placeholders for SAML 2.0 URIs.

Another important one is for initiating authentication from a relying party.

To do so, you can navigate to:

`+{baseUrl}/saml2/authenticate/{registrationId}+`

This is the default URI that's mapped to `Saml2WebSsoAuthenticationRequestFilter`.

By default, it will generate an `AuthNRequest` as a Redirect.
But your `RelyingPartyRegistration.AssertingParty#authenticationRequestBinding` property can be set to `POST`, and it will use POST instead.

[[servlet-saml2-authenticatedprincipal]]
==== Using `Saml2AuthenticatedPrincipal`

With the relying party correctly configured for a given asserting party, it's ready to accept assertions.
Once the relying party validates an assertion, the result is a `Saml2Authentication` with a `Saml2AuthenticatedPrincipal`.

This means that you can access the principal in your controller like so:

[source,java]
----
@Controller
public class MainController {
	@GetMapping("/")
	public String index(@AuthenticationPrincipal Saml2AuthenticatedPrincipal principal, Model model) {
		String email = principal.getFirstAttribute("email");
		model.setAttribute("email", email);
		return "index";
	}
}
----

[TIP]
Because the SAML 2.0 specification allows for each attribute to have multiple values, you can either call `getAttribute` to get the list of attributes or `getFirstAttribute` to get the first in the list.
`getFirstAttribute` is quite handy when you know that there is only one value.

[[servlet-saml2-sp-initiated-factory]]
==== Customizing the AuthNRequest

To adjust the `AuthNRequest`, you can publish an instance of `Saml2AuthenticationRequestFactory`.

For example, if you wanted to configure the `AuthNRequest` to request the IDP to send the SAML `Assertion` by REDIRECT, you could do:

[source,java]
----
@Bean
public Saml2AuthenticationRequestFactory authenticationRequestFactory() {
    OpenSamlAuthenticationRequestFactory authenticationRequestFactory =
        new OpenSamlAuthenticationRequestFactory();
    authenticationRequestFactory.setProtocolBinding("urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Redirect");
    return authenticationRequestFactory;
}
----

[[servlet-saml2-sp-initiated-factory-delegate]]
==== Delegating to an AuthenticationRequestFactory

Or, in circumstances where you need more control over what is sent as parameters to the `AuthenticationRequestFactory`, you can use delegation:

[source,java]
----
@Component
public class IssuerSaml2AuthenticationRequestFactory implements Saml2AuthenticationRequestFactory {
	private OpenSamlAuthenticationRequestFactory delegate = new OpenSamlAuthenticationRequestFactory();

	@Override
	public String createAuthenticationRequest(Saml2AuthenticationRequest request) {
		return this.delegate.createAuthenticationRequest(request);
	}

	@Override
    public Saml2PostAuthenticationRequest createPostAuthenticationRequest
        (Saml2AuthenticationRequestContext context) {

		String issuer = // ... calculate issuer

		Saml2AuthenticationRequestContext customIssuer = Saml2AuthenticationRequestContext.builder()
                .assertionConsumerServiceUrl(context.getAssertionConsumerServiceUrl())
                .issuer(issuer)
                .relayState(context.getRelayState())
                .relyingPartyRegistration(context.getRelyingPartyRegistration())
                .build();

		return this.delegate.createPostAuthenticationRequest(customIssuer);
	}

	@Override
    public Saml2RedirectAuthenticationRequest createRedirectAuthenticationRequest
        (Saml2AuthenticationRequestContext context) {

		throw new UnsupportedOperationException("unsupported");
	}
}
----

[[servlet-saml2-login-customize]]
=== Customizing Authentication Logic

By default Spring Security configures the `OpenSamlAuthenticationProvider`
to validate and parse the SAML 2 response and assertions that are received.
This provider has three configuration options

1. An authorities extractor - extract group information from the assertion
2. An authorities mapper - map extracted group information to internal authorities
3. Response time validation duration - the built in tolerances for timestamp validation
should be used when there may be a time synchronization issue.

One customization strategy is to use an `ObjectPostProcessor`, which allows you to modify the
objects created by the implementation. Another option is to override the authentication
manager for the filter that intercepts the SAMLResponse.

[[servlet-saml2-opensamlauthenticationprovider]]
==== OpenSamlAuthenticationProvider ObjectPostProcessor

[source,java]
----
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        ObjectPostProcessor<OpenSamlAuthenticationProvider> processor = new ObjectPostProcessor<>() {
            @Override
            public <O extends OpenSamlAuthenticationProvider> O postProcess(O provider) {
                provider.setResponseTimeValidationSkew(RESPONSE_TIME_VALIDATION_SKEW);
                provider.setAuthoritiesMapper(AUTHORITIES_MAPPER);
                provider.setAuthoritiesExtractor(AUTHORITIES_EXTRACTOR);
                return provider;
            }
        };

        http
            .authorizeRequests(authorize -> authorize
                .anyRequest().authenticated()
            )
            .saml2Login(saml2 -> saml2
               .addObjectPostProcessor(processor)
            )
        ;
    }
}
----

[[servlet-saml2-opensamlauthenticationprovider-authenticationmanager]]
==== Configure OpenSamlAuthenticationProvider as an Authentication Manager
We can leverage the same method, `authenticationManager`, to override and customize the default
`OpenSamlAuthenticationProvider`.

[source,java]
----
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        OpenSamlAuthenticationProvider authProvider = new OpenSamlAuthenticationProvider();
        authProvider.setResponseTimeValidationSkew(RESPONSE_TIME_VALIDATION_SKEW);
        authProvider.setAuthoritiesMapper(AUTHORITIES_MAPPER);
        authProvider.setAuthoritiesExtractor(AUTHORITIES_EXTRACTOR);
        http
            .authorizeRequests(authorize -> authorize
                .anyRequest().authenticated()
            )
            .saml2Login(saml2 -> saml2
                .authenticationManager(new ProviderManager(asList(authProvider)))
            )
        ;
    }
}
----

[[servlet-saml2-custom-authenticationmanager]]
==== Custom Authentication Manager
The authentication manager for the security filter can also be overwritten, using your own
custom `AuthenticationManager` implementation.
This authentication manager should expect a `Saml2AuthenticationToken` object
containing the SAML 2 Response XML data.

[source,java]
----
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        AuthenticationManager authenticationManager = new MySaml2AuthenticationManager(...);
        http
            .authorizeRequests(authorize -> authorize
                .anyRequest().authenticated()
            )
            .saml2Login(saml2 -> saml2
                .authenticationManager(authenticationManager)
            )
        ;
    }
}
----

[[servlet-saml2-sample-boot]]
=== Spring Boot 2.x Sample

We are currently working with the Spring Boot team on the
https://github.com/spring-projects/spring-boot/issues/18260[Auto Configuration for Spring Security SAML Login].
In the meantime, we have provided a Spring Boot sample that supports a Yaml configuration.

To run the sample, follow these three steps

1. Launch the Spring Boot application
** `./gradlew :spring-security-samples-boot-saml2login:bootRun`
2. Open a browser
** http://localhost:8080/[http://localhost:8080/]
3. This will take you to an identity provider, log in using:
** User: `user`
** Password: `password`

[[servlet-saml2-sample-idps]]
==== Multiple Identity Provider Sample

It's very simple to use multiple providers, but there are some defaults that
may trip you up if you don't pay attention. In our SAML configuration of
`RelyingPartyRegistration` objects, we default an SP entity ID to
`+{baseUrl}/saml2/service-provider-metadata/{registrationId}+`

That means in our two provider configuration, our system would look like

```
registration-1 (Identity Provider 1) - Our local SP Entity ID is:
http://localhost:8080/saml2/service-provider-metadata/registration-1

registration-2 (Identity Provider 2) - Our local SP Entity ID is:
http://localhost:8080/saml2/service-provider-metadata/registration-2
```

In this configuration, illustrated in the sample below, to the outside world,
we have actually created two virtual Service Provider identities
hosted within the same application.

[source,yaml]
----
spring:
  security:
    saml2:
      login:
        relying-parties:
          - entity-id: &idp-entity-id https://simplesaml-for-spring-saml.cfapps.io/saml2/idp/metadata.php
            registration-id: simplesamlphp
            web-sso-url: &idp-sso-url https://simplesaml-for-spring-saml.cfapps.io/saml2/idp/SSOService.php
            signing-credentials: &service-provider-credentials
              - private-key: |
                  -----BEGIN PRIVATE KEY-----
                  MIICeAIBADANBgkqhkiG9w0BAQEFAASCAmIwggJeAgEAAoGBANG7v8QjQGU3MwQE
                  ...................SHORTENED FOR READ ABILITY...................
                  INrtuLp4YHbgk1mi
                  -----END PRIVATE KEY-----
                certificate: |
                  -----BEGIN CERTIFICATE-----
                  MIICgTCCAeoCCQCuVzyqFgMSyDANBgkqhkiG9w0BAQsFADCBhDELMAkGA1UEBhMC
                  ...................SHORTENED FOR READ ABILITY...................
                  RZ/nbTJ7VTeZOSyRoVn5XHhpuJ0B
                  -----END CERTIFICATE-----
            verification-credentials: &idp-certificates
              - |
                -----BEGIN CERTIFICATE-----
                MIIEEzCCAvugAwIBAgIJAIc1qzLrv+5nMA0GCSqGSIb3DQEBCwUAMIGfMQswCQYD
                ...................SHORTENED FOR READ ABILITY...................
                lx13Y1YlQ4/tlpgTgfIJxKV6nyPiLoK0nywbMd+vpAirDt2Oc+hk
                -----END CERTIFICATE-----
          - entity-id: *idp-entity-id
            registration-id: simplesamlphp2
            web-sso-url: *idp-sso-url
            signing-credentials: *service-provider-credentials
            verification-credentials: *idp-certificates
----

If this is not desirable, you can manually override the local SP entity ID by using the

[source,attrs="-attributes"]
----
localEntityIdTemplate = {baseUrl}/saml2/service-provider-metadata
----

If we change our local SP entity ID to this value, it is still important that we give
out the correct single sign on URL (the assertion consumer service URL)
for each registered identity provider based on the registration Id.
`+{baseUrl}/login/saml2/sso/{registrationId}+`


